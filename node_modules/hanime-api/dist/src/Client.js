"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const util_1 = require("./util");
const constants_1 = __importDefault(require("./util/constants"));
const HanimeError_1 = require("./util/HanimeError");
const PartialVideo_1 = require("./structures/PartialVideo");
const Video_1 = require("./structures/Video");
const Tag_1 = require("./structures/Tag");
const Brand_1 = require("./structures/Brand");
const Storyboard_1 = require("./structures/Storyboard");
const SeasonalVideo_1 = require("./structures/SeasonalVideo");
/**
 * The main class for handling HTTP requests.
 */
class Client {
    constructor() {
        Object.defineProperties(this, {
            videos: { value: new Map() },
            storyboards: { value: new Map() },
        });
    }
    /**
     * Private method internally used for making requests.
     */
    request(base, url = '', data = {}) {
        return node_fetch_1.default(constants_1.default[base] + url, Object.assign(Object.assign({}, data), { headers: {
                'Content-Type': 'application/json',
            } })).then(d => d.json());
    }
    /**
     * Private method internally used for fetching the /browse endpoint.
     */
    browse() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.browseCache || (this.browseCache = yield this.request('BROWSE_URL'));
        });
    }
    /**
     * Private method internally used for fetching the main page.
     */
    landing() {
        return this.request('LANDING_URL');
    }
    /**
     * Search videos based on the specified string and options. Returns page-based results, use {@link searchAll} to get all results of all pages.
     * @param str The string to search. If empty, only the specified options apply.
     * @param options Other, optional options.
     */
    search(str, options) {
        return this
            .request('SEARCH_URL', '', {
            method: 'POST',
            body: JSON.stringify(util_1.resolveSearchOptions(str, options || {})),
        })
            .then(d => ({
            page: d.page,
            pageCount: d.nbPages,
            videoCount: d.nbHits,
            videosPerPage: d.hitsPerPage,
            videos: JSON.parse(d.hits).map(x => new PartialVideo_1.PartialVideo(this, x)),
        }));
    }
    /**
     * Returns all results of all pages of a {@link search}.
     * @param str The string to search. If empty, only the specified options apply.
     * @param options Other, optional options.
     */
    searchAll(str, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = [];
            let resLength;
            let i = 0;
            while (!resLength || res.length < resLength) {
                const { videos, videoCount } = yield this.search(str, Object.assign(Object.assign({}, options), { page: i++ }));
                if (!videos.length)
                    break;
                res.push(...videos);
                resLength = videoCount;
            }
            return res;
        });
    }
    /**
     * Get up to 500 videos published between 2 specified dates.
     * @param options The options to search according to.
     */
    fetchSeasons(options) {
        const res = util_1.resolveSeasonOptions(options);
        return this
            .request('SEASONS_URL', `${res.orderBy},${res.ordering}&released_at__gte=${res.from}&released_at__lt=${res.to}&__offset=${res.page}`)
            .then(d => ({
            videos: d.data.map(x => new SeasonalVideo_1.SeasonalVideo(this, x)),
            total: d.meta.total,
            page: res.page,
        }));
    }
    /**
     * Returns all results of all pages of a {@link fetchSeasons} call.
     * @param options The options to search according to.
     */
    fetchSeasonAll(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = [];
            let resLength;
            let i = 0;
            while (!resLength || res.length < resLength) {
                const { videos, total } = yield this.fetchSeasons(Object.assign(Object.assign({}, options), { page: i++ }));
                if (!videos.length)
                    break;
                res.push(...videos);
                resLength = total;
            }
            return res;
        });
    }
    /**
     * Fetch data of a video.
     * @param d The partial video, the slug or the ID to fetch.
     */
    fetchVideo(d) {
        return __awaiter(this, void 0, void 0, function* () {
            const slug = typeof d === 'string' || typeof d === 'number' ? `${d}` : d.slug;
            return this.videos.get(slug) || this
                .request('VIDEO_URL', slug)
                .then(d => {
                if (d.errors)
                    throw new HanimeError_1.HanimeError(d.errors[0]);
                const video = new Video_1.Video(this, d);
                this.videos.set(slug, video);
                this.videos.set(`${video.data.id}`, video);
                return video;
            });
        });
    }
    /**
     * Fetch the storyboards of a video. Doesn't accept a slug for uncached storyboards.
     * @param d The partial video, or ID of the video to fetch the storyboards of.
     */
    fetchStoryboards(d) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = `${typeof d === 'number' || typeof d === 'string' ? d : d.id}`;
            return this.storyboards.get(id) || this
                .request('STORYBOARDS_URL', id)
                .then(d => {
                if (d.errors)
                    throw new HanimeError_1.HanimeError(d.errors[0]);
                const data = d.hentai_video_storyboards.map(x => new Storyboard_1.Storyboard(x));
                this.storyboards.set(d.hv_slug, data);
                this.storyboards.set(id, data);
                return data;
            });
        });
    }
    /**
     * Fetch all available tags.
     */
    fetchTags() {
        return this
            .browse()
            .then(d => d.hentai_tags.map(x => new Tag_1.Tag(this, x)));
    }
    /**
     * Fetch all available brands.
     */
    fetchBrands() {
        return this
            .browse()
            .then(d => d.brands.map(x => new Brand_1.Brand(this, x)));
    }
    /**
     * Fetch recent video uploads.
     */
    fetchRecentUploads() {
        return this
            .landing()
            .then(d => d.sections
            .find(x => x.title === 'Recent Uploads')
            .hentai_video_ids.map(i => ({
            id: i,
            fetch: () => this.fetchVideo(i),
        })));
    }
    /**
     * Fetch recent releases.
     */
    fetchNewReleases() {
        return this
            .landing()
            .then(d => d.sections
            .find(x => x.title === 'New Releases')
            .hentai_video_ids.map(i => ({
            id: i,
            fetch: () => this.fetchVideo(i),
        })));
    }
    /**
     * Fetch trending videos.
     */
    fetchTrending() {
        return this
            .landing()
            .then(d => d.sections
            .find(x => x.title === 'Trending')
            .hentai_video_ids.map(i => ({
            id: i,
            fetch: () => this.fetchVideo(i),
        })));
    }
    /**
     * Fetch random videos.
     */
    fetchRandom() {
        return this
            .landing()
            .then(d => d.sections
            .find(x => x.title === 'Random')
            .hentai_video_ids.map(i => ({
            id: i,
            fetch: () => this.fetchVideo(i),
        })));
    }
}
exports.Client = Client;
